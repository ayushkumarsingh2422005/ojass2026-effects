<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broken Glass — Reassemble</title>
  <style>
    :root{--bg:#0d1021}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg),#071025);color:#fff}
    .wrap{width:min(880px,95vw);max-width:880px;padding:18px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.015));box-shadow:0 8px 40px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    h1{font-size:16px;margin:0;font-weight:600}
    p.subtitle{margin:0;color:rgba(255,255,255,0.65);font-size:13px}
    canvas{display:block;width:100%;height:auto;border-radius:8px;background:#111}
    .controls{margin-top:10px;display:flex;gap:8px;align-items:center}
    button{background:#0b74ff;border:none;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    input[type=file]{display:none}
    label.file{background:transparent;border:1px dashed rgba(255,255,255,0.08);padding:6px 10px;border-radius:8px;color:rgba(255,255,255,0.75);cursor:pointer}
    .muted{color:rgba(255,255,255,0.55);font-size:13px}
    .footer{margin-top:10px;color:rgba(255,255,255,0.45);font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Broken-glass piece reassemble — Click to assemble / scatter</h1>
        <p class="subtitle">Slices image into shards and animates them back into place.</p>
      </div>
      <div class="muted">Pieces: <span id="count">0</span></div>
    </header>

    <canvas id="c"></canvas>

    <div class="controls">
      <button id="toggle">Assemble</button>
      <button id="randomize">Randomize shards</button>
      <label class="file">Upload image <input id="file" type="file" accept="image/*"></label>
      <div style="flex:1"></div>
      <label class="muted">Rows <input id="rows" type="range" min="4" max="32" value="12"></label>
      <label class="muted">Cols <input id="cols" type="range" min="4" max="32" value="12"></label>
    </div>
    <div class="footer">Tip: click on the canvas to toggle assemble/scatter. Use upload to test your image. Default image is used if none provided.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const toggleBtn = document.getElementById('toggle');
  const randomizeBtn = document.getElementById('randomize');
  const fileInput = document.getElementById('file');
  const rowsRange = document.getElementById('rows');
  const colsRange = document.getElementById('cols');
  const countEl = document.getElementById('count');

  let W = 800, H = 800;
  let shards = [];
  let image = new Image();
  let isAssembled = false;
  let animationId = null;
  let imageLoaded = false;

  // Irregular shard class
  class Shard {
    constructor(cell, image, imageOffsetX, imageOffsetY, imageWidth, imageHeight) {
      this.cell = cell;
      this.vertices = cell.vertices;
      this.centroid = cell.centroid;
      this.image = image;
      this.imageOffsetX = imageOffsetX;
      this.imageOffsetY = imageOffsetY;
      this.imageWidth = imageWidth;
      this.imageHeight = imageHeight;
      
      // Calculate bounding box
      this.bbox = this.calculateBoundingBox();
      
      // Start in assembled position first, then scatter
      this.x = this.centroid.x;
      this.y = this.centroid.y;
      this.rotation = 0;
      
      // Initialize scattered positions
      this.scatteredX = this.centroid.x;
      this.scatteredY = this.centroid.y;
      this.scatteredRotation = 0;
      
      // Animation properties
      this.targetX = this.centroid.x;
      this.targetY = this.centroid.y;
      this.targetRotation = 0;
      this.vx = 0;
      this.vy = 0;
      this.vr = 0;
      
      // Scatter after a short delay
      setTimeout(() => {
        this.scatter();
      }, Math.random() * 1000);
    }
    
    calculateBoundingBox() {
      const xs = this.vertices.map(v => v.x);
      const ys = this.vertices.map(v => v.y);
      return {
        minX: Math.min(...xs),
        minY: Math.min(...ys),
        maxX: Math.max(...xs),
        maxY: Math.max(...ys),
        width: Math.max(...xs) - Math.min(...xs),
        height: Math.max(...ys) - Math.min(...ys)
      };
    }

    update(dt) {
      if (isAssembled) {
        // Move towards original position
        this.targetX = this.centroid.x;
        this.targetY = this.centroid.y;
        this.targetRotation = 0;
      } else {
        // Move towards scattered position
        this.targetX = this.scatteredX || this.x;
        this.targetY = this.scatteredY || this.y;
        this.targetRotation = this.scatteredRotation || this.rotation;
      }

      // Smooth spring physics with different parameters for assemble vs scatter
      const stiffness = isAssembled ? 0.12 : 0.08;
      const damping = isAssembled ? 0.88 : 0.85;
      
      this.vx += (this.targetX - this.x) * stiffness;
      this.vy += (this.targetY - this.y) * stiffness;
      this.vr += (this.targetRotation - this.rotation) * stiffness * 0.4;
      
      this.vx *= damping;
      this.vy *= damping;
      this.vr *= damping;
      
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rotation += this.vr * dt;
    }

    draw() {
      ctx.save();
      
      // Translate to current position and rotate
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      
      // Create clipping path for the irregular shape
      ctx.beginPath();
      this.vertices.forEach((vertex, index) => {
        const relativeX = vertex.x - this.centroid.x;
        const relativeY = vertex.y - this.centroid.y;
        if (index === 0) {
          ctx.moveTo(relativeX, relativeY);
        } else {
          ctx.lineTo(relativeX, relativeY);
        }
      });
      ctx.closePath();
      ctx.clip();
      
      // Draw the image portion within the clipped area
      const scaleX = this.image.naturalWidth / this.imageWidth;
      const scaleY = this.image.naturalHeight / this.imageHeight;
      
      ctx.drawImage(
        this.image,
        this.imageOffsetX * scaleX, this.imageOffsetY * scaleY, 
        this.imageWidth * scaleX, this.imageHeight * scaleY,
        -this.centroid.x, -this.centroid.y, 
        this.imageWidth, this.imageHeight
      );
      
      ctx.restore();
    }

    scatter() {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * Math.min(W, H) * 0.08; // Much smaller distance
      
      // Set target scattered position
      this.scatteredX = this.centroid.x + Math.cos(angle) * distance;
      this.scatteredY = this.centroid.y + Math.sin(angle) * distance;
      this.scatteredRotation = (Math.random() - 0.5) * Math.PI * 0.5; // Less rotation
      
      // Add some initial velocity for dynamic effect
      this.vx = Math.cos(angle) * distance * 0.02;
      this.vy = Math.sin(angle) * distance * 0.02;
      this.vr = (Math.random() - 0.5) * 0.05;
    }
  }

  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const size = Math.min(rect.width, 800);
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    W = H = size;
    canvas.width = W;
    canvas.height = H;
  }

  function createVoronoiCells(points, offsetX, offsetY, imageWidth, imageHeight) {
    const cells = [];
    
    // Create a proper Voronoi diagram using a grid-based approach
    const gridSize = 2; // Higher resolution for better coverage
    const gridWidth = Math.ceil(imageWidth / gridSize);
    const gridHeight = Math.ceil(imageHeight / gridSize);
    
    // Create a grid to assign each pixel to the nearest point
    const grid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(-1));
    
    // Assign each grid cell to the nearest point
    for (let y = 0; y < gridHeight; y++) {
      for (let x = 0; x < gridWidth; x++) {
        const worldX = offsetX + x * gridSize;
        const worldY = offsetY + y * gridSize;
        
        let minDist = Infinity;
        let closestPoint = 0;
        
        for (let i = 0; i < points.length; i++) {
          const dist = Math.sqrt(
            Math.pow(worldX - points[i].x, 2) + 
            Math.pow(worldY - points[i].y, 2)
          );
          if (dist < minDist) {
            minDist = dist;
            closestPoint = i;
          }
        }
        
        grid[y][x] = closestPoint;
      }
    }
    
    // Create cells by finding boundaries
    for (let i = 0; i < points.length; i++) {
      const cell = {
        center: points[i],
        vertices: [],
        centroid: { x: 0, y: 0 }
      };
      
      // Find all grid cells belonging to this point
      const cellPixels = [];
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          if (grid[y][x] === i) {
            cellPixels.push({ x: offsetX + x * gridSize, y: offsetY + y * gridSize });
          }
        }
      }
      
      if (cellPixels.length === 0) continue;
      
      // Calculate centroid
      cell.centroid.x = cellPixels.reduce((sum, p) => sum + p.x, 0) / cellPixels.length;
      cell.centroid.y = cellPixels.reduce((sum, p) => sum + p.y, 0) / cellPixels.length;
      
      // Create convex hull for the cell
      cell.vertices = createConvexHull(cellPixels);
      
      cells.push(cell);
    }
    
    return cells;
  }
  
  function createConvexHull(points) {
    if (points.length < 3) return points;
    
    // Simple convex hull using Graham scan
    const sorted = points.slice().sort((a, b) => a.x - b.x || a.y - b.y);
    const lower = [];
    const upper = [];
    
    for (const point of sorted) {
      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
        lower.pop();
      }
      lower.push(point);
    }
    
    for (let i = sorted.length - 1; i >= 0; i--) {
      const point = sorted[i];
      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], point) <= 0) {
        upper.pop();
      }
      upper.push(point);
    }
    
    lower.pop();
    upper.pop();
    return lower.concat(upper);
  }
  
  function cross(o, a, b) {
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }

  function createShards() {
    if (!imageLoaded) {
      console.log('Image not loaded yet');
      return;
    }
    
    shards = [];
    const numShards = parseInt(rowsRange.value) * parseInt(colsRange.value);
    
    // Calculate image scaling to fit canvas while maintaining aspect ratio
    const imageAspect = image.naturalWidth / image.naturalHeight;
    const canvasAspect = W / H;
    
    let imageWidth, imageHeight, offsetX, offsetY;
    
    if (imageAspect > canvasAspect) {
      // Image is wider than canvas
      imageWidth = W;
      imageHeight = W / imageAspect;
      offsetX = 0;
      offsetY = (H - imageHeight) / 2;
    } else {
      // Image is taller than canvas
      imageHeight = H;
      imageWidth = H * imageAspect;
      offsetX = (W - imageWidth) / 2;
      offsetY = 0;
    }
    
    // Generate better distributed points for Voronoi diagram
    const points = [];
    const minDistance = Math.min(imageWidth, imageHeight) / Math.sqrt(numShards) * 0.8;
    
    // Use Poisson disk sampling for better distribution
    for (let i = 0; i < numShards; i++) {
      let attempts = 0;
      let point;
      
      do {
        point = {
          x: offsetX + Math.random() * imageWidth,
          y: offsetY + Math.random() * imageHeight
        };
        attempts++;
      } while (attempts < 30 && points.some(p => 
        Math.sqrt(Math.pow(p.x - point.x, 2) + Math.pow(p.y - point.y, 2)) < minDistance
      ));
      
      points.push(point);
    }
    
    // Create Voronoi cells
    const cells = createVoronoiCells(points, offsetX, offsetY, imageWidth, imageHeight);
    
    // Create shards from Voronoi cells
    cells.forEach((cell, index) => {
      const shard = new Shard(cell, image, offsetX, offsetY, imageWidth, imageHeight);
      shards.push(shard);
    });
    
    countEl.textContent = shards.length;
    console.log(`Created ${shards.length} random shards`);
    console.log('Canvas size:', W, 'x', H);
    console.log('Image size:', imageWidth, 'x', imageHeight);
    console.log('Image offset:', offsetX, offsetY);
  }

  function animate() {
    const now = performance.now();
    const dt = 16.666 / 1000; // ~60fps
    
    // Update all shards
    shards.forEach(shard => shard.update(dt));
    
    // Clear and redraw
    ctx.clearRect(0, 0, W, H);
    
    // Draw all shards
    if (shards.length > 0) {
      shards.forEach(shard => {
        shard.draw();
      });
    } else {
      // Draw a test rectangle if no shards
      ctx.fillStyle = 'red';
      ctx.fillRect(50, 50, 100, 100);
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText('No shards created', 60, 120);
    }
    
    animationId = requestAnimationFrame(animate);
  }

  function toggle() {
    isAssembled = !isAssembled;
    toggleBtn.textContent = isAssembled ? 'Scatter' : 'Assemble';
    
    if (!isAssembled) {
      // Generate new scattered positions for all shards with staggered timing
      shards.forEach((shard, index) => {
        setTimeout(() => {
          shard.scatter();
        }, index * 20); // 20ms delay between each shard
      });
    }
  }

  function randomize() {
    createShards();
    isAssembled = false;
    toggleBtn.textContent = 'Assemble';
  }

  // Event listeners
  canvas.addEventListener('click', toggle);
  toggleBtn.addEventListener('click', toggle);
  randomizeBtn.addEventListener('click', randomize);
  rowsRange.addEventListener('input', randomize);
  colsRange.addEventListener('input', randomize);

  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      image.src = e.target.result;
      image.onload = () => {
        createShards();
        isAssembled = false;
        toggleBtn.textContent = 'Assemble';
      };
    };
    reader.readAsDataURL(file);
  });

  // Initialize
  image.onload = () => {
    console.log('Image loaded successfully');
    imageLoaded = true;
    fitCanvas();
    createShards();
    animate();
  };
  
  image.onerror = () => {
    console.error('Failed to load image');
    // Create a fallback colored rectangle
    imageLoaded = true;
    fitCanvas();
    
    // Create a simple colored canvas as fallback
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = W;
    tempCanvas.height = H;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Draw a gradient background
    const gradient = tempCtx.createLinearGradient(0, 0, W, H);
    gradient.addColorStop(0, '#ff6b6b');
    gradient.addColorStop(0.5, '#4ecdc4');
    gradient.addColorStop(1, '#45b7d1');
    tempCtx.fillStyle = gradient;
    tempCtx.fillRect(0, 0, W, H);
    
    // Draw some text
    tempCtx.fillStyle = 'white';
    tempCtx.font = '48px Arial';
    tempCtx.textAlign = 'center';
    tempCtx.fillText('DJ', W/2, H/2);
    
    // Create random shards from this fallback
    const numShards = parseInt(rowsRange.value) * parseInt(colsRange.value);
    
    // Generate random points for Voronoi diagram
    const points = [];
    for (let i = 0; i < numShards; i++) {
      points.push({
        x: Math.random() * W,
        y: Math.random() * H
      });
    }
    
    // Create Voronoi cells
    const cells = createVoronoiCells(points, 0, 0, W, H);
    
    // Create shards from Voronoi cells
    shards = [];
    cells.forEach((cell, index) => {
      const shard = new Shard(cell, tempCanvas, 0, 0, W, H);
      shards.push(shard);
    });
    
    countEl.textContent = shards.length;
    animate();
  };
  
  // Try to load the image
  image.src = './Main.png';

  window.addEventListener('resize', () => {
    fitCanvas();
    if (shards.length > 0) {
      createShards();
    }
  });

  // Initial setup
  fitCanvas();
  
  // Add some debugging info
  console.log('Canvas size:', W, 'x', H);
  console.log('Image source:', image.src);
})();
</script>
</body>
</html>